"""
Utilities for convolving families of kernels with data.

Author: Ankit N. Khambhati
Adapted from: https://github.com/pennmem/ptsa_new/blob/master/ptsa/wavelet.py
Last Updated: 2018/08/31
"""

import numpy as np
from scipy.signal import fftconvolve


def fconv(kernel, signal, boundary=None):
    """
    Convolve kernel bank with multidimensional signals using FFT.

    Parameters
    ----------
    kernel: np.ndarray, shape: [n_sample_1, n_kernel]
        Array of kernels (generated by `family` module)
    signal: np.ndarray, shape: [n_sample_2, n_signal]
        Multidimensional signal array (must be two dimensional)
    boundary: {None, 'mirror'}
        Specifies how to handle the boundary of the signal.

    Returns
    -------
    arr_conv: np.ndarray, shape: [n_sample_2, n_kernel, n_signal]
    """

    # get the number of signals and samples in each input
    n_sample_1, n_kernel = kernel.shape
    n_sample_2, n_signal = signal.shape
    if n_sample_1 > n_sample_2:
        raise ValueError('Kernel cannot have greater length than signal.')

    # Handle boundary case
    if boundary == 'mirror':
        signal_lead = signal[:n_sample_1, :][::-1, :]
        signal_lag = signal[-n_sample_1:, :][::-1, :]
        signal = np.concatenate((signal_lead, signal, signal_lag))
        n_sample_2 = signal.shape[0]

    # Pre-allocate array
    n_s = n_sample_1 + n_sample_2 - 1
    arr_conv = np.zeros((n_s, n_kernel, n_signal), dtype=np.complex)
    for s_i in range(n_signal):
        arr_conv[:, :, s_i] = fftconvolve(
            kernel, signal[:, s_i].reshape(-1, 1), mode='full')

    # Clip the convolved signal to the signal length
    arr_conv = arr_conv[centered(arr_conv.shape[0], n_sample_2), :, :]

    # Remove the mirrored buffer
    if boundary == 'mirror':
        arr_conv = arr_conv[n_sample_1:-n_sample_1, ...]

    return arr_conv


def centered(curr_size, new_size):
    """
    Use with convolution, return center indices for an array of a specific len.

    Parameters
    ----------
    curr_size: int
        Length of dimension to truncate in the current array.
    new_size: int
        Intended length of the dimension to truncate in the new array.

    Returns
    -------
    ind: np.ndarray, shape: (new_size,)
        Indices to excise the center portion along one dimension
        of the current array.
    """

    curr_size = int(curr_size)
    new_size = int(new_size)
    if new_size >= curr_size:
        raise ValueError('New size must be shorter than the current size.')

    startind = (curr_size - new_size) // 2
    endind = startind + new_size

    return np.array(np.arange(startind, endind), dtype=np.int)
