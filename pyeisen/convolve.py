"""
Utilities for convolving families of kernels with data.

Author: Ankit N. Khambhati
Adapted from: https://github.com/pennmem/ptsa_new/blob/master/ptsa/wavelet.py
Last Updated: 2018/09/11
"""

import numpy as np
import scipy.fftpack


def fconv(kernel,
          signal,
          fft=scipy.fftpack.fft,
          ifft=scipy.fftpack.ifft,
          boundary=None,
          interp_nan=True):
    """
    Convolve kernel bank with multidimensional signals using FFT.

    Parameters
    ----------
    kernel: np.ndarray, shape: [n_sample_1, n_kernel]
        Array of kernels (generated by `family` module)
    signal: np.ndarray, shape: [n_sample_2, n_signal]
        Multidimensional signal array (must be two dimensional)
    fft/ifft: Function handles to a routine that calls fft.
        By default, this code uses scipy.fftpack, however it will also accept
        the pyfftw `builders` objects.
    boundary: {None, 'mirror'}
        Specifies how to handle the boundary of the signal.
    interp_nan: bool
        Specifies whether to return interpolated result or to add
        NaNs back into the convolved signal.

    Returns
    -------
    arr_conv: np.ndarray, shape: [n_sample_2, n_kernel, n_signal]
    """

    # Convert to complex types
    kernel = np.asarray(kernel, dtype=complex)
    signal = np.asarray(signal, dtype=complex)

    # get the number of signals and samples in each input
    n_sample_1, n_kernel = kernel.shape
    n_sample_2, n_signal = signal.shape
    n_s = n_sample_1 + n_sample_2

    # Handle boundary case
    if boundary == 'mirror':
        signal_lead = signal[:n_sample_1, :][::-1, :]
        signal_lag = signal[-n_sample_1:, :][::-1, :]
        signal = np.concatenate((signal_lead, signal, signal_lag))
        n_sample_2 = signal.shape[0]

    # Handle NaNs and Infs
    mask_nan = ~np.isfinite(signal)
    signal[mask_nan] = 0

    # Pre-allocate array
    arr_conv = np.zeros((n_sample_2, n_kernel, n_signal), dtype=complex)

    # Pre-compute `FFT Kernel`
    try:
        fft.input_array[...] = 0
        fft.input_array[centered(n_s, n_sample_1), :] = kernel[:, :]
        fft.input_array[...] = np.fft.ifftshift(fft.input_array, axes=0)
        fft_kernel = fft().copy()
    except Exception as e:
        print(e)
        big_arr = np.zeros((n_s, n_kernel), dtype=complex)
        big_arr[centered(n_s, n_sample_1), :] = kernel[:, :]
        big_arr = np.fft.ifftshift(big_arr, axes=0)
        fft_kernel = scipy.fftpack.fft(big_arr, axis=0)

    # Pre-compute `FFT Energy`
    try:
        fft.input_array[...] = 0
        fft.input_array[centered(n_s, n_sample_1), :] = np.abs(kernel**2)
        fft.input_array[...] = np.fft.ifftshift(fft.input_array, axes=0)
        fft_energy = fft().copy()
    except Exception as e:
        print(e)
        big_arr = np.zeros((n_s, n_kernel), dtype=complex)
        big_arr[centered(n_s, n_sample_1), :] = np.abs(kernel**2)
        big_arr = np.fft.ifftshift(big_arr, axes=0)
        fft_energy = scipy.fftpack.fft(big_arr, axis=0)

    # Iterate over each signal dimension
    for s_i in range(n_signal):

        # Compute signal FFT
        try:
            fft.input_array[...] = 0
            fft.input_array[centered(n_s, n_sample_2), :] = \
                    signal[:, s_i].reshape(-1, 1)
            fft_signal = fft()
        except Exception as e:
            print(e)
            big_arr = np.zeros((n_s, n_kernel), dtype=complex)
            big_arr[centered(n_s, n_sample_2), :] = \
                    signal[:, s_i].reshape(-1, 1)
            fft_signal = scipy.fftpack.fft(big_arr, axis=0)

        # Convolve main signal with kernel
        fft_sigkern = fft_signal * fft_kernel

        # Compute main_kernel iFFT
        try:
            ifft.input_array[:, :] = fft_sigkern[...]
            ifft_sigkern = ifft().copy()
        except Exception as e:
            print(e)
            ifft_sigkern = scipy.fftpack.ifft(fft_sigkern, axis=0)

        # Compute mask FFT
        try:
            fft.input_array[...] = 0
            fft.input_array[centered(n_s, n_sample_2), :] = \
                    np.asarray(1.0 - mask_nan[:, s_i], dtype=complex).reshape(-1, 1)
            fft_missing = fft()
        except Exception as e:
            print(e)
            big_arr = np.zeros((n_s, n_kernel), dtype=complex)
            big_arr[centered(n_s, n_sample_2), :] = \
                    (1.0 - mask_nan[:, s_i]).reshape(-1, 1)
            fft_missing = scipy.fftpack.fft(big_arr, axis=0)

        # Convolve mask signal with kernel
        fft_missnrg = fft_missing * fft_energy

        # Compute miss_energy iFFT
        try:
            ifft.input_array[:, :] = fft_missnrg
            ifft_missnrg = np.sqrt(ifft())
        except Exception as e:
            print(e)
            ifft_missnrg = np.sqrt(scipy.fftpack.ifft(fft_missnrg, axis=0))

        # Final inverse transform gives the convolution,
        # normalized by segment of valid kernel (non-NaN portion)
        sigkern_missnrg = ifft_sigkern / ifft_missnrg
        sigkern_missnrg[ifft_missnrg < (
            10 * np.finfo(ifft_missnrg.dtype).eps)] = 0.0

        # Clip the convolved signal to the signal length
        arr_conv[:, :, s_i] = sigkern_missnrg[centered(n_s, n_sample_2), :]

        # Put NaN back
        if not interp_nan:
            arr_conv[mask_nan[:, s_i], :, s_i] = np.nan

    # Remove the mirrored buffer
    if boundary == 'mirror':
        arr_conv = arr_conv[n_sample_1:-n_sample_1, ...]

    return arr_conv


def centered(curr_size, new_size):
    """
    Use with convolution, return center indices for an array of a specific len.

    Parameters
    ----------
    curr_size: int
        Length of dimension to truncate in the current array.
    new_size: int
        Intended length of the dimension to truncate in the new array.

    Returns
    -------
    ind: np.ndarray, shape: (new_size,)
        Indices to excise the center portion along one dimension
        of the current array.
    """

    curr_size = int(curr_size)
    new_size = int(new_size)

    center = curr_size - (curr_size + 1) // 2
    return slice(center - (new_size) // 2, center + (new_size + 1) // 2)
